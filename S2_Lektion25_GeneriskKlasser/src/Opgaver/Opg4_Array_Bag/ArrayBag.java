package Opgaver.Opg4_Array_Bag;public class ArrayBag<T> implements Bag<T> {    private T[] elements;    private int currentSize;    private int INITIALSIZE = 20;    public ArrayBag() {        this.elements = (T[]) new Object[INITIALSIZE]; // Opretter et nyt array af generisk type T med initial størrelse INITIALSIZE    }    @Override    public int getCurrentSize() {        return currentSize; // Returnerer antallet af elementer i tasken    }    @Override    public boolean isFull() {        return currentSize == elements.length; // Returnerer true, hvis tasken er fuld (antallet af elementer er lig med arrayets længde)    }    @Override    public boolean isEmpty() {        return currentSize == 0; // Returnerer true, hvis tasken er tom (antallet af elementer er 0)    }    @Override    public boolean add(T newEntry) {        boolean added = false;        if (!isFull()) { // Hvis tasken ikke er fuld            elements[currentSize + 1] = newEntry; // Tilføjer det nye element til positionen efter det sidste element i tasken            added = true; // Elementet blev tilføjet        }        currentSize++; // Øger antallet af elementer i tasken        return added; // Returnerer true, hvis elementet blev tilføjet, ellers false    }    @Override    public T remove() {        T elementToBeRemoved = elements[currentSize - 1]; // Gemmer det sidste element i tasken, der skal fjernes        if (elementToBeRemoved != null) { // Hvis der er et element at fjerne            currentSize--; // Reducerer antallet af elementer i tasken        }        elements[currentSize] = null; // Sætter den tidligere sidste position til null (fjerner elementet)        return elementToBeRemoved; // Returnerer det fjernede element    }    @Override    public boolean remove(T anEntry) {        boolean found = false;        for (int i = 0; i < elements.length; i++) {            if (elements[i] == anEntry) { // Hvis elementet findes i tasken                elements[i] = null; // Sætter elementet til null                moveArrayItems(i); // Flytter elementerne i arrayet for at fjerne det fjernede element                found = true; // Elementet blev fjernet                currentSize--; // Reducerer antallet af elementer i tasken            }        }        return found; // Returnerer true, hvis elementet blev fjernet, ellers false    }    public void moveArrayItems(int index) {        for (int i = index; i < elements.length; i++) {            elements[i] = elements[i - 1]; // Flytter elementerne i arrayet ved at erstatte hvert element med det forrige element        }    }    @Override    public void clear() {        for (int i = 0; i < elements.length; i++) {            elements[i] = null; // Sætter hvert element i arrayet til null for at fjerne alle elementer        }        currentSize = 0; // Nulstiller antallet af elementer i tasken til 0    }    @Override    public int getFrequencyOf(T anEntry) {        int count = 0;        for (int i = 0; i < elements.length; i++) {            if (elements[i] == anEntry) { // Hvis elementet findes i tasken                count++; // Øger tælleren            }        }        return count; // Returnerer antallet af forekomster af elementet i tasken    }    @Override    public boolean contains(T anEntry) {        boolean found = false;        for (int i = 0; i < elements.length; i++) {            if (elements[i] == anEntry) { // Hvis elementet findes i tasken                found = true; // Elementet blev fundet            }        }        return found; // Returnerer true, hvis elementet blev fundet, ellers false    }    @Override    public T[] toArray() {        T[] newArray = (T[]) new Object[currentSize]; // Opretter et nyt array af generisk type T med størrelsen currentSize        for (int i = 0; i < currentSize; i++) {            newArray[i] = elements[i]; // Kopierer elementerne fra det oprindelige array til det nye array        }        return newArray; // Returnerer det nye array    }}